####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router


class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.lsdb = {}  # {router: {neighbor: cost}}
        self.seq = {}   # {router: seq_num}
        self.my_links = {}  # {neighbor: cost}
        self.ports = {}  # {neighbor: port}
        self.fwd = {}   # {dst: port}
        self.my_seq = 0

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dst_addr in self.fwd:
                self.send(self.fwd[packet.dst_addr], packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            import json
            try:
                data = json.loads(packet.content)
                who = data['origin']
                seq = data['seq']
                links = data['links']
            except:
                return
            if who not in self.seq or seq > self.seq[who]:
                self.seq[who] = seq
                self.lsdb[who] = links
                self._dijkstra()
                for n, p in self.ports.items():
                    if p != port:
                        from packet import Packet
                        pkt = Packet(Packet.ROUTING, self.addr, n, packet.content)
                        self.send(p, pkt)

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.my_links[endpoint] = cost
        self.ports[endpoint] = port
        self.my_seq += 1
        self.lsdb[self.addr] = dict(self.my_links)
        self.seq[self.addr] = self.my_seq
        self._dijkstra()
        self._flood()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        gone = None
        for n, p in self.ports.items():
            if p == port:
                gone = n
                break
        if gone:
            self.my_links.pop(gone, None)
            self.ports.pop(gone, None)
            self.my_seq += 1
            self.lsdb[self.addr] = dict(self.my_links)
            self.seq[self.addr] = self.my_seq
            self._dijkstra()
            self._flood()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            self.my_seq += 1
            self.lsdb[self.addr] = dict(self.my_links)
            self.seq[self.addr] = self.my_seq
            self._flood()

    def _flood(self):
        import json
        from packet import Packet
        msg = json.dumps({'origin': self.addr, 'seq': self.my_seq, 'links': self.my_links})
        for n, p in self.ports.items():
            pkt = Packet(Packet.ROUTING, self.addr, n, msg)
            self.send(p, pkt)

    def _dijkstra(self):
        import heapq
        graph = {}
        for r in self.lsdb:
            graph[r] = dict(self.lsdb[r])
        if self.addr not in graph:
            graph[self.addr] = dict(self.my_links)
        dist = {self.addr: 0}
        prev = {}
        heap = [(0, self.addr)]
        while heap:
            d, u = heapq.heappop(heap)
            for v in graph.get(u, {}):
                c = graph[u][v]
                if v not in dist or d + c < dist[v]:
                    dist[v] = d + c
                    prev[v] = u
                    heapq.heappush(heap, (dist[v], v))
        fwd = {}
        for dst in dist:
            if dst == self.addr:
                continue
            hop = dst
            while prev.get(hop) != self.addr and hop in prev:
                hop = prev[hop]
            if prev.get(hop) == self.addr and hop in self.ports:
                fwd[dst] = self.ports[hop]
        self.fwd = fwd

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"